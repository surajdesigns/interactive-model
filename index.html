<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neural Engine V8.5 (Hyper-Sense Upgrade)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; }
        
        /* HUD UI */
        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: #fff; 
            background: rgba(10, 10, 15, 0.85);
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.2);
            border-left: 4px solid #ff0055; /* Dynamic Accent */
            border-radius: 12px;
            backdrop-filter: blur(8px);
            min-width: 280px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            transition: border-color 0.3s ease;
        }

        h1 { margin: 0 0 15px 0; font-size: 16px; letter-spacing: 2px; color: #eee; border-bottom: 1px solid rgba(255,255,255,0.15); padding-bottom: 10px;}

        .info-row { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 13px; align-items: center; }
        .val { font-weight: bold; color: #fff; text-shadow: 0 0 8px rgba(255,255,255,0.4); }

        #gesture-status {
            margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.15);
            text-align: center; font-size: 13px; color: #aaa; font-weight: bold; letter-spacing: 1px;
        }
        .active-trigger { color: #fff !important; text-shadow: 0 0 15px #fff; background: rgba(255,255,255,0.1); border-radius: 4px; padding: 2px 0;}

        /* Camera Feed */
        #camera-preview {
            position: absolute; bottom: 30px; right: 30px; z-index: 10;
            width: 320px; height: 240px; 
            border: 2px solid rgba(255,255,255,0.3); border-radius: 12px;
            overflow: hidden; transform: scaleX(-1); opacity: 0.8;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            background: #000;
        }
        video { width: 100%; height: 100%; object-fit: cover; }
        
        .controls { font-size: 11px; color: #888; margin-top: 15px; line-height: 1.6; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; }
        b { color: #ccc; }
        
        /* Loading Overlay */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100; display: flex; align-items: center; justify-content: center;
            color: #fff; font-size: 20px; pointer-events: none; transition: opacity 1s;
        }
    </style>
</head>
<body>

<div id="loader">INITIALIZING NEURAL CORE V8.5...</div>

<div id="hud">
    <h1>NEURAL CORE V8.5</h1>
    <div class="info-row"><span>SYSTEM</span> <span class="val" id="shape-name">NEON HEART</span></div>
    <div class="info-row"><span>DEPTH</span> <span class="val" id="zoom-text">1.0x</span></div>
    <div class="info-row"><span>ROTATION</span> <span class="val" id="rot-text">0.0</span></div>
    <div class="info-row"><span>ENERGY</span> <span class="val" id="charge-text">0%</span></div>
    
    <div id="gesture-status">WAITING FOR HAND...</div>
    
    <div class="controls">
        <b>âœŠ FIST:</b> TIME FREEZE<br>
        <b>âœ‹ OPEN PALM:</b> EXPLODE PARTICLES<br>
        <b>ðŸ«° SNAP:</b> CHANGE SHAPE<br>
        <b>ðŸ‘‹ ROTATE:</b> SPIN HAND<br>
        <b>ðŸ‘Œ PINCH:</b> CHARGE ENERGY
    </div>
</div>

<div id="camera-preview"><video id="input_video" playsinline></video></div>
<div id="canvas-container"></div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// --- CONFIG ---
const PARTICLE_COUNT = 45000; 
const SHAPES = ['heart', 'blackhole', 'cube', 'dna', 'galaxy', 'saturn'];
const LABELS = ['NEON HEART', 'EVENT HORIZON', 'HYPER CUBE', 'DNA HELIX', 'SPIRAL GALAXY', 'SATURN RINGS'];

// Theme Colors
const THEMES = [
    { h: 0.95, s: 1.0, l: 0.6 }, // Heart (Red)
    { h: 0.55, s: 1.0, l: 0.6 }, // Blackhole (Cyan/Blue)
    { h: 0.10, s: 1.0, l: 0.6 }, // Cube (Gold)
    { h: 0.33, s: 1.0, l: 0.6 }, // DNA (Green)
    { h: 0.75, s: 0.9, l: 0.7 }, // Galaxy (Purple)
    { h: 0.05, s: 0.8, l: 0.8 }  // Saturn (Orange/White)
];

let currentShapeIdx = 0;

// --- ADVANCED STATE ---
const state = {
    // Basic
    zoom: 1.0,
    targetZoom: 1.0,
    pulse: 1.0,
    
    // Hand Tracking Data
    handDetected: false,
    handPosition: new THREE.Vector3(0, 0, 0), // Normalized -1 to 1
    rawHandPosition: new THREE.Vector3(0, 0, 0), // Unsmoothed
    
    // Gestures
    isFrozen: false,       // Fist
    isExploding: false,    // Open Palm
    explodeFactor: 0.0,    // Animation value for explosion
    isCharging: false,     // Pinch Hold
    chargeLevel: 0.0,      // 0.0 to 1.0
    
    // Snap Logic
    snapPrimed: false,     // Has the user pinched middle+thumb?
    lastSnapTime: 0,       // Debounce timer

    // Rotation Logic
    rotationAngle: 0,
    rotationVelocity: 0.002, // Base auto-spin
    lastHandAngle: null,
    
    // Movement Logic
    sceneOffset: new THREE.Vector3(0, 0, 0),
    
    // Swipe Logic
    swipeVelocityX: 0,
    lastSwipeX: 0,
    swipeCooldown: 0
};

// --- THREE.JS SETUP ---
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 13;

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.getElementById('canvas-container').appendChild(renderer.domElement);

// --- BLOOM ---
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloomPass.strength = 0.8; // Slight boost
bloomPass.radius = 0.5;
bloomPass.threshold = 0.15;
composer.addPass(bloomPass);

// --- TEXTURE ---
function createCrispTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    
    const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.4, 'rgba(255,255,255,0.6)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,32,32);
    return new THREE.CanvasTexture(canvas);
}

const geometry = new THREE.BufferGeometry();
const posArray = new Float32Array(PARTICLE_COUNT * 3);
const targetArray = new Float32Array(PARTICLE_COUNT * 3);
const colors = new Float32Array(PARTICLE_COUNT * 3);
const initialPos = new Float32Array(PARTICLE_COUNT * 3); // For freeze memory

for(let i=0; i<PARTICLE_COUNT; i++) {
    const i3 = i*3;
    posArray[i3] = (Math.random()-0.5) * 50;
    posArray[i3+1] = (Math.random()-0.5) * 50;
    posArray[i3+2] = (Math.random()-0.5) * 50;
    targetArray[i3] = posArray[i3];
    initialPos[i3] = posArray[i3];
}

geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
    size: 0.12,
    map: createCrispTexture(),
    vertexColors: true,
    transparent: true,
    opacity: 1.0,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    sizeAttenuation: true
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

// --- VISUAL CURSOR (HAND TRACKING POINT) ---
// This provides instant visual feedback before physics smoothing kicks in
const cursorGeo = new THREE.SphereGeometry(0.1, 16, 16);
const cursorMat = new THREE.MeshBasicMaterial({ 
    color: 0xff0055, 
    transparent: true, 
    opacity: 0.0, // Hidden until hand found
    blending: THREE.AdditiveBlending 
});
const handCursor = new THREE.Mesh(cursorGeo, cursorMat);
// Add a glow sprite to cursor
const spriteMat = new THREE.SpriteMaterial({ 
    map: createCrispTexture(), 
    color: 0xff0055, 
    transparent: true, 
    blending: THREE.AdditiveBlending 
});
const cursorGlow = new THREE.Sprite(spriteMat);
cursorGlow.scale.set(1.5, 1.5, 1.5);
handCursor.add(cursorGlow);
scene.add(handCursor);


// --- SHAPE LOGIC ---
function updateTargets() {
    const type = SHAPES[currentShapeIdx];
    const theme = THEMES[currentShapeIdx];
    
    // UI Update
    document.getElementById('shape-name').innerText = LABELS[currentShapeIdx];
    const hueVal = theme.h * 360;
    document.getElementById('hud').style.borderLeftColor = `hsl(${hueVal}, 100%, 50%)`;
    
    // Cursor Color Update
    const col = new THREE.Color().setHSL(theme.h, 1.0, 0.6);
    handCursor.material.color.copy(col);
    cursorGlow.material.color.copy(col);

    // Trigger Animation
    const status = document.getElementById('gesture-status');
    status.innerText = "SHAPE CHANGED";
    status.classList.add('active-trigger');
    setTimeout(() => {
        status.classList.remove('active-trigger');
    }, 600);

    for(let i=0; i<PARTICLE_COUNT; i++) {
        const i3 = i*3;
        const pt = i / PARTICLE_COUNT;
        const theta = pt * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        
        let x=0, y=0, z=0;

        // --- SHAPE FORMULAS ---
        if (type === 'heart') {
            const t = theta;
            const r = Math.sqrt(Math.random()); 
            x = 16 * Math.pow(Math.sin(t), 3);
            y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            z = (Math.random()-0.5) * 6;
            x *= 0.35 * r; y *= 0.35 * r; z *= r;
        } 
        else if (type === 'blackhole') {
            const r = 3 + Math.random() * 8;
            const spiral = theta * 10;
            x = r * Math.cos(spiral);
            y = r * Math.sin(spiral);
            z = (Math.random()-0.5) * (r * 0.2); 
        } 
        else if (type === 'cube') {
            const dim = 6;
            x = (Math.random()-0.5) * dim;
            y = (Math.random()-0.5) * dim;
            z = (Math.random()-0.5) * dim;
            if (Math.random()>0.5) {
                if(Math.random()>0.5) x = Math.sign(x)*dim*0.5;
                else if(Math.random()>0.5) y = Math.sign(y)*dim*0.5;
                else z = Math.sign(z)*dim*0.5;
            }
        }
        else if (type === 'dna') {
            const strands = 2; 
            const heightSpan = 22;
            let h = (pt * heightSpan) - (heightSpan/2);
            const angle = h * 0.7; 
            const radius = 3.5;
            const particleType = i % 10; 

            if (particleType < 4) {
                x = Math.cos(angle) * radius + (Math.random()-0.5)*0.3;
                z = Math.sin(angle) * radius + (Math.random()-0.5)*0.3;
                y = h;
            } else if (particleType < 8) {
                x = Math.cos(angle + Math.PI) * radius + (Math.random()-0.5)*0.3;
                z = Math.sin(angle + Math.PI) * radius + (Math.random()-0.5)*0.3;
                y = h;
            } else {
                const t = Math.random(); 
                const x1 = Math.cos(angle) * radius;
                const z1 = Math.sin(angle) * radius;
                const x2 = Math.cos(angle + Math.PI) * radius;
                const z2 = Math.sin(angle + Math.PI) * radius;
                x = x1 + (x2 - x1) * t;
                z = z1 + (z2 - z1) * t;
                y = h;
            }
        }
        else if (type === 'galaxy') {
            const arms = 4;
            const spin = theta * arms;
            const r = pt * 12;
            x = r * Math.cos(spin + r*0.5);
            z = r * Math.sin(spin + r*0.5);
            y = (Math.random()-0.5) * (15-r) * 0.2;
        }
        else if (type === 'saturn') {
             if (i < PARTICLE_COUNT * 0.3) {
                 const r = 3;
                 x = r * Math.sin(phi) * Math.cos(theta);
                 y = r * Math.sin(phi) * Math.sin(theta);
                 z = r * Math.cos(phi);
             } else {
                 const r = 5 + Math.random() * 4;
                 x = r * Math.cos(theta * 8);
                 z = r * Math.sin(theta * 8);
                 y = (Math.random()-0.5) * 0.1;
             }
        }

        targetArray[i3] = x;
        targetArray[i3+1] = y;
        targetArray[i3+2] = z;
    }
}
updateTargets();

// --- HAND TRACKING ---
const script1 = document.createElement('script');
script1.src = "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js";
const script2 = document.createElement('script');
script2.src = "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js";

script1.onload = () => document.head.appendChild(script2);
script2.onload = () => {
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    // Optimize for better tracking
    hands.setOptions({ 
        maxNumHands: 1, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.6, // Slightly lower for faster detection
        minTrackingConfidence: 0.6 
    });
    hands.onResults(onHandResults);
    
    const cameraFeed = new Camera(document.getElementById('input_video'), {
        onFrame: async () => await hands.send({ image: document.getElementById('input_video') }),
        width: 640, height: 480
    });
    cameraFeed.start();
    
    setTimeout(() => { document.getElementById('loader').style.opacity = 0; }, 2000);
};
document.head.appendChild(script1);

// Helper Math
function dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
// Standard Lerp
function lerp(start, end, amt) { return (1 - amt) * start + amt * end; }
// Adaptive Lerp (Faster when distance is large)
function adaptiveLerp(start, end, minSpeed, maxSpeed) {
    const diff = Math.abs(end - start);
    // If different is high, move fast. If low, move slow (smooth).
    const speed = minSpeed + (Math.min(diff, 1.0) * (maxSpeed - minSpeed));
    return start + (end - start) * speed;
}

// --- GESTURE RECOGNITION ---
function onHandResults(results) {
    const statusEl = document.getElementById('gesture-status');
    const hud = document.getElementById('hud');
    
    if (!results.multiHandLandmarks || !results.multiHandLandmarks[0]) {
        state.handDetected = false;
        statusEl.innerText = "WAITING FOR HAND...";
        statusEl.className = "";
        handCursor.material.opacity = 0; // Hide cursor
        
        // Reset physics slightly when hand lost
        state.rotationVelocity = lerp(state.rotationVelocity, 0.002, 0.05);
        state.sceneOffset.lerp(new THREE.Vector3(0,0,0), 0.05);
        state.targetZoom = lerp(state.targetZoom, 1.0, 0.05);
        
        // Reset Gestures
        state.isFrozen = false;
        state.isExploding = false;
        state.isCharging = false;
        state.snapPrimed = false;
        state.chargeLevel = Math.max(0, state.chargeLevel - 0.05);
        return;
    }

    state.handDetected = true;
    handCursor.material.opacity = 0.8; // Show cursor

    const lm = results.multiHandLandmarks[0];
    const palm = lm[0];
    const indexTip = lm[8];
    const thumbTip = lm[4];
    const middleTip = lm[12];
    
    // 1. UPDATE HAND POSITION
    const targetX = (palm.x - 0.5) * 2;
    const targetY = -(palm.y - 0.5) * 2;
    
    // Store raw for calculations
    state.rawHandPosition.set(targetX, targetY, 0);

    // Adaptive Smoothing for Scene Movement:
    // If moving fast, increase lerp factor (0.2). If slow, decrease (0.05) for steadiness.
    const moveDist = state.handPosition.distanceTo(state.rawHandPosition);
    const smoothFactor = 0.05 + Math.min(moveDist * 2, 0.15); 
    
    state.handPosition.lerp(state.rawHandPosition, smoothFactor);

    // Update Cursor Position Instantly (Visual feedback needs to be fast)
    handCursor.position.set(targetX * 5, targetY * 5, 2);

    // 2. DEPTH / ZOOM (Z-AXIS)
    // Scale based on distance between wrist(0) and middle_finger_mcp(9) 
    const handSize = dist(lm[0], lm[9]);
    const targetZ = 0.5 + (handSize * 4.0); 
    state.targetZoom = lerp(state.targetZoom, targetZ, 0.1);
    
    // 3. FIST DETECTION (FREEZE)
    // Hysteresis: Trigger at < 0.10, Release at > 0.14
    const fingerTips = [8, 12, 16, 20];
    const avgDistToPalm = fingerTips.reduce((sum, id) => sum + dist(lm[id], lm[0]), 0) / 4;
    
    if (avgDistToPalm < 0.11) state.isFrozen = true;
    else if (avgDistToPalm > 0.15) state.isFrozen = false;
    
    // 4. OPEN PALM (EXPLODE)
    // Trigger at > 0.25
    const isfingersFar = fingerTips.every(id => dist(lm[id], lm[0]) > 0.25);
    state.isExploding = isfingersFar;

    // 5. PINCH (CHARGE) -> Index + Thumb
    const pinchDist = dist(thumbTip, indexTip);
    state.isCharging = pinchDist < 0.05;

    // 6. SNAP DETECTION (CHANGE SHAPE) -> Middle + Thumb
    const snapDist = dist(thumbTip, middleTip);
    const now = Date.now();

    // Prime the snap (Thumb touches Middle finger)
    if (snapDist < 0.06) {
        state.snapPrimed = true;
    } 
    // Trigger the snap (Rapid release)
    else if (state.snapPrimed && snapDist > 0.14) {
        state.snapPrimed = false; // Reset prime
        
        // Debounce (prevent double snaps)
        if (now - state.lastSnapTime > 600) {
            state.lastSnapTime = now;
            
            // EXECUTE SNAP ACTION
            currentShapeIdx = (currentShapeIdx + 1) % SHAPES.length;
            updateTargets();
            
            statusEl.innerText = "ðŸ«° SNAP!";
            statusEl.className = "active-trigger";
        }
    }

    // 7. ROTATION (Index vs Palm Angle)
    const angle = Math.atan2(indexTip.y - palm.y, indexTip.x - palm.x);
    if (state.lastHandAngle !== null && !state.isFrozen && !state.isExploding) {
        let delta = angle - state.lastHandAngle;
        if (delta > Math.PI) delta -= Math.PI * 2;
        if (delta < -Math.PI) delta += Math.PI * 2;
        
        // Adaptive Rotation Smoothing
        const rotSpeed = Math.abs(delta);
        const rotLerp = rotSpeed > 0.1 ? 0.4 : 0.05; // Snappy spin vs Smooth coasting
        state.rotationVelocity = lerp(state.rotationVelocity, delta * 3.0, rotLerp);
    }
    state.lastHandAngle = angle;

    // --- STATE MACHINE & UI ---
    
    // Priority: Fist > Open > Pinch > Snap(Event) > Idle
    if (state.isFrozen) {
        statusEl.innerText = "âœŠ TIME FREEZE";
        statusEl.className = "active-trigger";
    } else if (state.isExploding) {
        statusEl.innerText = "âœ‹ NOVA BURST";
        statusEl.className = "active-trigger";
    } else if (state.isCharging) {
        state.chargeLevel = Math.min(1.0, state.chargeLevel + 0.03); // Faster charge
        statusEl.innerText = `âš¡ CHARGING ${Math.floor(state.chargeLevel*100)}%`;
        statusEl.className = "active-trigger";
    } else {
        // IDLE / ROTATE
        state.chargeLevel = Math.max(0, state.chargeLevel - 0.05);
        
        // Only show status if not recently snapped
        if (now - state.lastSnapTime > 800) {
            if (state.snapPrimed) {
                statusEl.innerText = "READY TO SNAP...";
                statusEl.style.color = "#ff0055";
            } else if (Math.abs(state.rotationVelocity) > 0.02) {
                statusEl.innerText = "SPINNING";
                statusEl.className = "";
                statusEl.style.color = "#aaa";
            } else {
                statusEl.innerText = "HAND ACTIVE";
                statusEl.className = "";
                statusEl.style.color = "#aaa";
            }
        }
    }

    // Move Shape based on Hand Position (Inverse camera movement feel)
    const targetOffset = new THREE.Vector3(
        state.handPosition.x * 5, 
        state.handPosition.y * 5, 
        0
    );
    // Smooth dampening for the main shape (The cursor is instant, the shape lags slightly for weight)
    state.sceneOffset.lerp(targetOffset, 0.12);
}

// --- ANIMATION LOOP ---
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    // Pulse Logic
    if (SHAPES[currentShapeIdx] === 'heart') {
        const beat = Math.sin(time * 3);
        state.pulse = 1 + (beat > 0.8 ? 0.1 : 0);
    } else {
        state.pulse = 1;
    }

    // Smooth Zoom Transition
    state.zoom += (state.targetZoom - state.zoom) * 0.1;
    
    // HUD Updates
    document.getElementById('zoom-text').innerText = state.zoom.toFixed(2) + "x";
    document.getElementById('rot-text').innerText = (state.rotationVelocity * 100).toFixed(1);
    document.getElementById('charge-text').innerText = Math.floor(state.chargeLevel*100) + "%";

    // Explode Logic
    const targetExplode = state.isExploding ? 1.0 : 0.0;
    state.explodeFactor = lerp(state.explodeFactor, targetExplode, 0.1); // Faster explosion reaction

    // Rotation Physics (Inertia)
    if (!state.isFrozen) {
        // Apply friction
        state.rotationVelocity *= 0.95; 
        state.rotationAngle += state.rotationVelocity;
    }

    // Pulse the cursor
    if(state.handDetected) {
        const s = 1.0 + Math.sin(time * 10) * 0.1;
        handCursor.scale.set(s,s,s);
    }

    // --- PARTICLE PHYSICS UPDATE ---
    
    const positions = geometry.attributes.position.array;
    const colorsArr = geometry.attributes.color.array;
    const currentTheme = THEMES[currentShapeIdx];
    
    const cosRot = Math.cos(state.rotationAngle);
    const sinRot = Math.sin(state.rotationAngle);

    for(let i=0; i<PARTICLE_COUNT; i++) {
        const i3 = i*3;

        // 1. FREEZE CHECK
        if (state.isFrozen) {
            positions[i3] += (Math.random()-0.5) * 0.02;
            positions[i3+1] += (Math.random()-0.5) * 0.02;
            positions[i3+2] += (Math.random()-0.5) * 0.02;
            
            colorsArr[i3] = lerp(colorsArr[i3], 0.8, 0.1);
            colorsArr[i3+1] = lerp(colorsArr[i3+1], 0.9, 0.1);
            colorsArr[i3+2] = lerp(colorsArr[i3+2], 1.0, 0.1);
            continue; 
        }

        // 2. BASE TARGET CALCULATION
        let tx = targetArray[i3] * state.zoom * state.pulse;
        let ty = targetArray[i3+1] * state.zoom * state.pulse;
        let tz = targetArray[i3+2] * state.zoom * state.pulse;

        // 3. ROTATION (Around Y axis)
        const rx = tx * cosRot - tz * sinRot;
        const rz = tx * sinRot + tz * cosRot;
        tx = rx; tz = rz;

        // 4. EXPLOSION MODIFIER
        if (state.explodeFactor > 0.01) {
            const dist = Math.sqrt(tx*tx + ty*ty + tz*tz) + 0.1;
            const force = 12 * state.explodeFactor; // Strength
            tx += (tx/dist) * force * (1 + Math.random());
            ty += (ty/dist) * force * (1 + Math.random());
            tz += (tz/dist) * force * (1 + Math.random());
        }

        // 5. HAND MAGNET (Subtle Attraction)
        // Only if not charging/exploding
        if (state.handDetected && !state.isExploding && !state.isCharging) {
            // handPosition is -1 to 1. Map to world coordinates approx (-10 to 10)
            const handX = state.handPosition.x * 5; // Reduced multiplier for better alignment
            const handY = state.handPosition.y * 5;
            
            const dx = handX - tx;
            const dy = handY - ty;
            const d = Math.sqrt(dx*dx + dy*dy);
            
            if (d < 6) {
                const pull = (6 - d) * 0.03; // Stronger pull
                tx += dx * pull;
                ty += dy * pull;
            }
        }

        // 6. GLOBAL HAND OFFSET (Minority Report Slide)
        tx += state.sceneOffset.x;
        ty += state.sceneOffset.y;

        // 7. PHYSICS INTEGRATION (Lerp)
        // Adaptive Physics: If exploding, move fast. If normal, move smooth.
        const ease = state.isExploding ? 0.2 : 0.15; 
        
        positions[i3] += (tx - positions[i3]) * ease;
        positions[i3+1] += (ty - positions[i3+1]) * ease;
        positions[i3+2] += (tz - positions[i3+2]) * ease;

        // 8. COLOR DYNAMICS
        const distToCenter = Math.sqrt(tx*tx + ty*ty + tz*tz);
        
        let hue = currentTheme.h + (distToCenter*0.01);
        let sat = currentTheme.s;
        let light = currentTheme.l;

        // Charge Effect (Turn White/Bright)
        if (state.isCharging) {
            light += state.chargeLevel * 0.5; // Boost brightness
            sat -= state.chargeLevel * 0.8;   // Desaturate to white
        }

        // Explosion Heat
        if (state.isExploding) {
            hue = 0.05 + (Math.random() * 0.1); // Fire colors
            light = 0.9;
        }

        const color = new THREE.Color();
        color.setHSL(hue, sat, light);

        colorsArr[i3] = color.r;
        colorsArr[i3+1] = color.g;
        colorsArr[i3+2] = color.b;
    }

    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.color.needsUpdate = true;
    
    composer.render();
}

animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
